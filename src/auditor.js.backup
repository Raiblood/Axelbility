const fs = require('fs').promises;
const cheerio = require('cheerio');
const axe = require('axe-core');

class Axelbility {
  constructor(options = {}) {
    this.options = {
      strict: options.strict || false,
      autoFix: options.autoFix || false,
      rules: options.rules || this.getDefaultRules()
    };
    this.results = {
      violations: [],
      fixes: [],
      warnings: []
    };
  }

  /**
   * Auditar un archivo HTML
   * @param {string} filePath - Ruta al archivo HTML
   * @returns {Promise<Object>} - Resultados de auditoría
   */
  async auditFile(filePath) {
    try {
      // Leer archivo
      const html = await fs.readFile(filePath, 'utf-8');

      // Parsear HTML
      const $ = cheerio.load(html);

      // Ejecutar reglas
      await this.checkMissingAltText($);
      await this.checkAriaHidden($);
      await this.checkAccordionAria($);
      await this.checkHeadingOrder($);
      await this.checkButtonTypes($);

      return {
        file: filePath,
        passed: this.results.violations.length === 0,
        violations: this.results.violations,
        fixes: this.results.fixes,
        warnings: this.results.warnings
      };

    } catch (error) {
      throw new Error(`Error auditing ${filePath}: ${error.message}`);
    }
  }

  /**
   * Regla: Verificar imágenes sin alt text
   */
  async checkMissingAltText($) {
    $('img').each((i, elem) => {
      const $img = $(elem);
      const src = $img.attr('src') || 'unknown';

      if (!$img.attr('alt') && $img.attr('alt') !== '') {
        this.results.violations.push({
          type: 'missing-alt',
          severity: 'critical',
          element: 'img',
          src: src,
          message: `Image missing alt attribute: ${src}`,
          wcag: '1.1.1 (Level A)',
          line: this.getLineNumber($, elem)
        });
      }
    });
  }

  /**
   * Regla: Verificar iconos sin aria-hidden
   */
  async checkAriaHidden($) {
    const iconSelectors = 'i.icon, i.fas, i.far, i.fab, i[class*="fa-"]';

    $(iconSelectors).each((i, elem) => {
      const $icon = $(elem);

      if (!$icon.attr('aria-hidden')) {
        const className = $icon.attr('class') || 'unknown';

        this.results.violations.push({
          type: 'icon-missing-aria-hidden',
          severity: 'moderate',
          element: 'i',
          class: className,
          message: `Decorative icon missing aria-hidden="true": ${className}`,
          wcag: '4.1.2 (Level A)',
          autoFixable: true
        });
      }
    });
  }

  /**
   * Regla: Verificar acordeones sin ARIA
   */
  async checkAccordionAria($) {
    $('button[data-bs-toggle="collapse"]').each((i, elem) => {
      const $button = $(elem);
      const target = $button.attr('data-bs-target');

      if (!$button.attr('aria-expanded')) {
        this.results.violations.push({
          type: 'accordion-missing-aria-expanded',
          severity: 'critical',
          element: 'button',
          target: target,
          message: `Accordion button missing aria-expanded: ${target}`,
          wcag: '4.1.2 (Level A)',
          autoFixable: true
        });
      }

      if (!$button.attr('aria-controls')) {
        this.results.violations.push({
          type: 'accordion-missing-aria-controls',
          severity: 'critical',
          element: 'button',
          target: target,
          message: `Accordion button missing aria-controls: ${target}`,
          wcag: '4.1.2 (Level A)',
          autoFixable: true
        });
      }
    });
  }

  /**
   * Regla: Verificar orden de headings
   */
  async checkHeadingOrder($) {
    const headings = $('h1, h2, h3, h4, h5, h6');
    let lastLevel = 0;

    headings.each((i, elem) => {
      const currentLevel = parseInt(elem.tagName.replace('h', ''));

      if (currentLevel - lastLevel > 1) {
        this.results.warnings.push({
          type: 'heading-order-skip',
          severity: 'moderate',
          element: elem.tagName,
          message: `Heading skips level: ${elem.tagName} after h${lastLevel}`,
          wcag: '2.4.6 (Level AA)',
          autoFixable: false
        });
      }

      lastLevel = currentLevel;
    });
  }

  /**
   * Regla: Verificar botones sin type
   */
  async checkButtonTypes($) {
    $('button').each((i, elem) => {
      const $button = $(elem);

      if (!$button.attr('type')) {
        this.results.violations.push({
          type: 'button-missing-type',
          severity: 'moderate',
          element: 'button',
          message: 'Button missing type attribute (should be "button", "submit", or "reset")',
          wcag: '4.1.2 (Level A)',
          autoFixable: true
        });
      }
    });
  }

  /**
   * Obtener número de línea aproximado (simplificado)
   */
  getLineNumber($, elem) {
    // Implementación básica - en producción usar parser más sofisticado
    return 'N/A';
  }

  /**
   * Reglas por defecto
   */
  getDefaultRules() {
    return [
      'missing-alt',
      'icon-missing-aria-hidden',
      'accordion-missing-aria',
      'heading-order',
      'button-missing-type'
    ];
  }
}

module.exports = Axelbility;